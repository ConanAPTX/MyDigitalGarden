---
{"number headings":"auto, first-level 5, max 6, contents
{ #toc}
, start-at 1, _.1.1","dg-publish":true,"permalink":"/15_OceanBase/05_OceanBase 性能调优/Sql 调优指南/Sql 请求执行流程/","dgPassFrontmatter":true}
---


#### 1 Sql 请求执行流程

SQL 引擎从接受 SQL 请求到执行的典型流程如下图所示：

![Sql 请求执行流程.jpg|800](/img/user/02_%E9%99%84%E4%BB%B6/Image/15_OceanBase/Sql%20%E8%AF%B7%E6%B1%82%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.jpg)

##### 1 Fast-parser：
仅使用词法分析对文本串直接参数化，获取参数化后的文本及常量参数；


##### 2 Parser，词法/语法解析模块：
在收到用户发送的 SQL 请求串后，Parser 会将字符串分成一个个的"单词"，并根据预先设定好的语法规则解析整个请求，将 SQL 请求字符串转换成带有语法结构信息的内存数据结构，称为语法树（Syntax Tree）；


##### 3 Plan Cache，执行计划缓存模块：
执行计划缓存模块会将该 SQL 第一次生成的执行计划缓存在内存中，后续的执行可以反复执行这个计划，避免了重复查询优化的过程；


##### 4 Resolver，语义解析模块：
Resolver 将生成的语法树转换为带有数据库语义信息的内部数据结构。在这一过程中，Resolver 将根据数据库元信息将 SQL 请求中的 Token 翻译成对应的对象（例如库、表、列、索引等），生成的数据结构叫做 Statement Tree，即语句树；


##### 5 Transformer，逻辑改写模块：
在查询优化中，经常利用等价改写的方式，将用户SQL转换为与之等价的另一条SQL，以便于优化器为之生成最佳的执行计划，我们称这一过程为“查询改写”；
Transformer 在 resolver 之后， 分析用户SQL的语义，并根据内部的规则或代价模型，将用户SQL“改写”为与之等价的其他形式，并将其提供给后续的优化器做进一步的优化；
分析用户 SQL 的语义，并根据内部的规则或代价模型，将用户 SQL 改写为与之等价的其他形式，并将其提供给后续的优化器做进一步的优化。Transformer 的工作方式是在原 Statement Tree 上做等价变换，变换的结果仍然是一棵 Statement Tree；


##### 6 Optimizer，优化器：
优化器是整个 SQL 请求优化的核心，其作用是为 SQL 请求生成最佳的执行计划。
在优化过程中，优化器需要综合考虑 SQL 请求的语义、对象数据特征、对象物理分布等多方面因素，解决访问路径选择、联接顺序选择、联接算法选择、分布式计划生成等多个核心问题，最终选择一个对应该 SQL 的最佳执行计划；
为了充分利用OceanBase的分布式架构和多核计算资源的优势，OceanBase的查询优化器会对执行计划做并行优化：根据计划树上各个节点的数据分布，对串行执行计划进行自底向上的分析，把串行的逻辑执行计划改造成一个可以并行执行的逻辑计划；


##### 7 Code Generator，代码生成器：
将执行计划转换为可执行的代码，但是不做任何优化选择；


##### 8 Executor，执行器：
启动 SQL 的执行过程。

- 对于本地执行计划，Executor 会简单的从执行计划的顶端的算子开始调用，根据算子自身的逻辑完成整个执行的过程，并返回执行结果；
- 对于远程或分布式计划，将执行树分成多个可以调度的子计划，并通过 RPC 将其发送给相关的节点去执行；


### 参考文档
1. [SQL 请求执行流程](https://www.oceanbase.com/docs/common-oceanbase-database-cn-10000000001692964)，；



